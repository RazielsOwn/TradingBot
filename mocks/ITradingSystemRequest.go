// Code generated by mockery 2.12.1. DO NOT EDIT.

package mocks

import (
	context "context"
	entity "trading_bot/internal/entity"

	decimal "github.com/shopspring/decimal"

	mock "github.com/stretchr/testify/mock"

	testing "testing"
)

// ITradingSystemRequest is an autogenerated mock type for the ITradingSystemRequest type
type ITradingSystemRequest struct {
	mock.Mock
}

// Buy provides a mock function with given fields: ctx, tradingSystemPair, tradingSystemPrice, internalPrice, amount, internalPair
func (_m *ITradingSystemRequest) Buy(ctx context.Context, tradingSystemPair string, tradingSystemPrice decimal.Decimal, internalPrice decimal.Decimal, amount decimal.Decimal, internalPair string) bool {
	ret := _m.Called(ctx, tradingSystemPair, tradingSystemPrice, internalPrice, amount, internalPair)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, string, decimal.Decimal, decimal.Decimal, decimal.Decimal, string) bool); ok {
		r0 = rf(ctx, tradingSystemPair, tradingSystemPrice, internalPrice, amount, internalPair)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// GetCryptoAddress provides a mock function with given fields: ctx, currency, tradingSystemWithdrawalNetwork
func (_m *ITradingSystemRequest) GetCryptoAddress(ctx context.Context, currency string, tradingSystemWithdrawalNetwork string) string {
	ret := _m.Called(ctx, currency, tradingSystemWithdrawalNetwork)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, string, string) string); ok {
		r0 = rf(ctx, currency, tradingSystemWithdrawalNetwork)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetPublicTradingOrders provides a mock function with given fields: ctx, tradingSystemPair, usdcTradingLimit, cryptoTradingLimit, internalCryptoBalance, internalUsdcBalance, pairMinAmount
func (_m *ITradingSystemRequest) GetPublicTradingOrders(ctx context.Context, tradingSystemPair string, usdcTradingLimit decimal.Decimal, cryptoTradingLimit decimal.Decimal, internalCryptoBalance decimal.Decimal, internalUsdcBalance decimal.Decimal, pairMinAmount decimal.Decimal) []*entity.TradingOrder {
	ret := _m.Called(ctx, tradingSystemPair, usdcTradingLimit, cryptoTradingLimit, internalCryptoBalance, internalUsdcBalance, pairMinAmount)

	var r0 []*entity.TradingOrder
	if rf, ok := ret.Get(0).(func(context.Context, string, decimal.Decimal, decimal.Decimal, decimal.Decimal, decimal.Decimal, decimal.Decimal) []*entity.TradingOrder); ok {
		r0 = rf(ctx, tradingSystemPair, usdcTradingLimit, cryptoTradingLimit, internalCryptoBalance, internalUsdcBalance, pairMinAmount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.TradingOrder)
		}
	}

	return r0
}

// GetTradingBalances provides a mock function with given fields: ctx
func (_m *ITradingSystemRequest) GetTradingBalances(ctx context.Context) map[string]*entity.BalanceObject {
	ret := _m.Called(ctx)

	var r0 map[string]*entity.BalanceObject
	if rf, ok := ret.Get(0).(func(context.Context) map[string]*entity.BalanceObject); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]*entity.BalanceObject)
		}
	}

	return r0
}

// Sell provides a mock function with given fields: ctx, tradingSystemPair, tradingSystemPrice, internalPrice, amount, internalPair
func (_m *ITradingSystemRequest) Sell(ctx context.Context, tradingSystemPair string, tradingSystemPrice decimal.Decimal, internalPrice decimal.Decimal, amount decimal.Decimal, internalPair string) bool {
	ret := _m.Called(ctx, tradingSystemPair, tradingSystemPrice, internalPrice, amount, internalPair)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, string, decimal.Decimal, decimal.Decimal, decimal.Decimal, string) bool); ok {
		r0 = rf(ctx, tradingSystemPair, tradingSystemPrice, internalPrice, amount, internalPair)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Withdraw provides a mock function with given fields: ctx, addr, withdrawalAmount, currency, tradingSystemWithdrawalNetwork
func (_m *ITradingSystemRequest) Withdraw(ctx context.Context, addr string, withdrawalAmount decimal.Decimal, currency string, tradingSystemWithdrawalNetwork string) bool {
	ret := _m.Called(ctx, addr, withdrawalAmount, currency, tradingSystemWithdrawalNetwork)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, string, decimal.Decimal, string, string) bool); ok {
		r0 = rf(ctx, addr, withdrawalAmount, currency, tradingSystemWithdrawalNetwork)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// NewITradingSystemRequest creates a new instance of ITradingSystemRequest. It also registers the testing.TB interface on the mock and a cleanup function to assert the mocks expectations.
func NewITradingSystemRequest(t testing.TB) *ITradingSystemRequest {
	mock := &ITradingSystemRequest{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

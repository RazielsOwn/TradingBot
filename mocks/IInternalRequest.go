// Code generated by mockery 2.12.1. DO NOT EDIT.

package mocks

import (
	context "context"
	entity "trading_bot/internal/entity"

	decimal "github.com/shopspring/decimal"

	mock "github.com/stretchr/testify/mock"

	null "gopkg.in/guregu/null.v4"

	testing "testing"

	uuid "github.com/gofrs/uuid"
)

// IInternalRequest is an autogenerated mock type for the IInternalRequest type
type IInternalRequest struct {
	mock.Mock
}

// AddOrder provides a mock function with given fields: ctx, currencyFrom, currencyTo, amount, price, isSellOrder
func (_m *IInternalRequest) AddOrder(ctx context.Context, currencyFrom string, currencyTo string, amount decimal.Decimal, price decimal.Decimal, isSellOrder bool) (bool, uuid.UUID) {
	ret := _m.Called(ctx, currencyFrom, currencyTo, amount, price, isSellOrder)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, string, string, decimal.Decimal, decimal.Decimal, bool) bool); ok {
		r0 = rf(ctx, currencyFrom, currencyTo, amount, price, isSellOrder)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 uuid.UUID
	if rf, ok := ret.Get(1).(func(context.Context, string, string, decimal.Decimal, decimal.Decimal, bool) uuid.UUID); ok {
		r1 = rf(ctx, currencyFrom, currencyTo, amount, price, isSellOrder)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(uuid.UUID)
		}
	}

	return r0, r1
}

// GetBalances provides a mock function with given fields: ctx
func (_m *IInternalRequest) GetBalances(ctx context.Context) map[string]*entity.BalanceObject {
	ret := _m.Called(ctx)

	var r0 map[string]*entity.BalanceObject
	if rf, ok := ret.Get(0).(func(context.Context) map[string]*entity.BalanceObject); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]*entity.BalanceObject)
		}
	}

	return r0
}

// GetCompleteOrder provides a mock function with given fields: ctx, orderId, jetCryptoPair
func (_m *IInternalRequest) GetCompleteOrder(ctx context.Context, orderId uuid.UUID, jetCryptoPair string) []*entity.InternalOrder {
	ret := _m.Called(ctx, orderId, jetCryptoPair)

	var r0 []*entity.InternalOrder
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string) []*entity.InternalOrder); ok {
		r0 = rf(ctx, orderId, jetCryptoPair)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.InternalOrder)
		}
	}

	return r0
}

// GetCryptoAddress provides a mock function with given fields: ctx, currency
func (_m *IInternalRequest) GetCryptoAddress(ctx context.Context, currency string) string {
	ret := _m.Called(ctx, currency)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, currency)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetOrder provides a mock function with given fields: ctx, orderId, jetCryptoPair
func (_m *IInternalRequest) GetOrder(ctx context.Context, orderId uuid.UUID, jetCryptoPair string) *entity.InternalOrder {
	ret := _m.Called(ctx, orderId, jetCryptoPair)

	var r0 *entity.InternalOrder
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string) *entity.InternalOrder); ok {
		r0 = rf(ctx, orderId, jetCryptoPair)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.InternalOrder)
		}
	}

	return r0
}

// GetOrders provides a mock function with given fields: ctx, jetCryptoPair
func (_m *IInternalRequest) GetOrders(ctx context.Context, jetCryptoPair string) map[uuid.UUID]*entity.InternalOrder {
	ret := _m.Called(ctx, jetCryptoPair)

	var r0 map[uuid.UUID]*entity.InternalOrder
	if rf, ok := ret.Get(0).(func(context.Context, string) map[uuid.UUID]*entity.InternalOrder); ok {
		r0 = rf(ctx, jetCryptoPair)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[uuid.UUID]*entity.InternalOrder)
		}
	}

	return r0
}

// GetTradingPairInfo provides a mock function with given fields: ctx, jetCryptoPair
func (_m *IInternalRequest) GetTradingPairInfo(ctx context.Context, jetCryptoPair string) decimal.Decimal {
	ret := _m.Called(ctx, jetCryptoPair)

	var r0 decimal.Decimal
	if rf, ok := ret.Get(0).(func(context.Context, string) decimal.Decimal); ok {
		r0 = rf(ctx, jetCryptoPair)
	} else {
		r0 = ret.Get(0).(decimal.Decimal)
	}

	return r0
}

// IsPaymentCompleted provides a mock function with given fields: ctx, orderId
func (_m *IInternalRequest) IsPaymentCompleted(ctx context.Context, orderId uuid.UUID) bool {
	ret := _m.Called(ctx, orderId)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) bool); ok {
		r0 = rf(ctx, orderId)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// RemoveOrder provides a mock function with given fields: ctx, orderId, currencyFrom, currencyTo
func (_m *IInternalRequest) RemoveOrder(ctx context.Context, orderId uuid.UUID, currencyFrom string, currencyTo string) bool {
	ret := _m.Called(ctx, orderId, currencyFrom, currencyTo)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, string) bool); ok {
		r0 = rf(ctx, orderId, currencyFrom, currencyTo)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Withdraw provides a mock function with given fields: ctx, addr, destinationTag, withdrawalAmount, currentCurrencyId
func (_m *IInternalRequest) Withdraw(ctx context.Context, addr string, destinationTag string, withdrawalAmount decimal.Decimal, currentCurrencyId string) null.Int {
	ret := _m.Called(ctx, addr, destinationTag, withdrawalAmount, currentCurrencyId)

	var r0 null.Int
	if rf, ok := ret.Get(0).(func(context.Context, string, string, decimal.Decimal, string) null.Int); ok {
		r0 = rf(ctx, addr, destinationTag, withdrawalAmount, currentCurrencyId)
	} else {
		r0 = ret.Get(0).(null.Int)
	}

	return r0
}

// NewIInternalRequest creates a new instance of IInternalRequest. It also registers the testing.TB interface on the mock and a cleanup function to assert the mocks expectations.
func NewIInternalRequest(t testing.TB) *IInternalRequest {
	mock := &IInternalRequest{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
